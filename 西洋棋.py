# -*- coding: utf-8 -*-
"""西洋棋.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17W54ONpw8SUKkGDQyzFjo1-wOxOl0BFe
"""

#queen
cur_x, cur_y = map(int, input().split())
tar_x, tar_y = map(int, input().split())

actual_delta_x = tar_x - cur_x
actual_delta_y = tar_y - cur_y

if cur_x == tar_x and cur_y == tar_y:
  print("No")
elif checkerboard[tar_x][tar_y] == 1:
  print("No")

# 水平移動 (y不變, x變)
elif actual_delta_y == 0 and actual_delta_x != 0: # 確保真的有水平移動
  path_clear = True
  step_x = 1 if actual_delta_x > 0 else -1
  for i in range(1, abs(actual_delta_x)):
    check_x = cur_x + step_x * i
    if checkerboard[check_x][cur_y] == 1:
      path_clear = False
      break
  if path_clear:
    print("Yes")
  else:
    print("No")

# 垂直移動 (x不變, y變)
elif actual_delta_x == 0 and actual_delta_y != 0: # 確保真的有垂直移動
  path_clear = True
  step_y = 1 if actual_delta_y > 0 else -1
  for i in range(1, abs(actual_delta_y)):
    check_y = cur_y + step_y * i
    if checkerboard[cur_x][check_y] == 1: # <<< --- 修正點
      path_clear = False
      break
  if path_clear:
    print("Yes")
  else:
    print("No")

# 斜線移動 (x和y的移動格數絕對值相同, 且都不為0)
elif abs(actual_delta_x) == abs(actual_delta_y) and actual_delta_x != 0: # actual_delta_x != 0 隱含 actual_delta_y != 0
  path_clear = True
  step_x = 1 if actual_delta_x > 0 else -1
  step_y = 1 if actual_delta_y > 0 else -1
  for i in range(1, abs(actual_delta_x)):
    check_x = cur_x + i * step_x
    check_y = cur_y + i * step_y
    if checkerboard[check_x][check_y] == 1: # 這裡的索引是正確的
      path_clear = False
      break
  if path_clear:
    print("Yes")
  else:
    print("No")
else:
  print("No")

#soider
checkerboard = [
  [1, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0] ]
cur_x, cur_y = map(int, input().split())
tar_x, tar_y = map(int, input().split())



if cur_x==tar_x and cur_y==tar_y:
  print("No")
elif checkerboard[tar_x][tar_y]==1:
  print("No")
elif cur_x+1==tar_x:
  print("No")
else:
  print("No")

#騎士
cur_x, cur_y = map(int, input().split())
tar_x, tar_y = map(int, input().split())

actual_delta_x = tar_x - cur_x
actual_delta_y = tar_y - cur_y

# 檢查是否停在原地
if cur_x == tar_x and cur_y == tar_y:
    print("No")
elif checkerboard[tar_x][tar_y] == 1:
    print("No")
else:
    is_knight_move = False
    # 模式1: x方向移動2格，y方向移動1格
    if abs(actual_delta_x) == 2 and abs(actual_delta_y) == 1:
        is_knight_move = True
    # 模式2: x方向移動1格，y方向移動2格
    elif abs(actual_delta_x) == 1 and abs(actual_delta_y) == 2:
        is_knight_move = True

    if is_knight_move:
        print("Yes")
    else:
        print("No")

#king
board = [
  [1, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0] ]
cur_x, cur_y = map(int, input().split())
tar_x, tar_y = map(int, input().split())
delta_x = abs(cur_x - tar_x)
delta_y = abs(cur_y - tar_y)

if cur_x==tar_x and cur_y==tar_y:
  print("No")
elif board[tar_x][tar_y]==1:
  print("No")
elif not (delta_x <= 1 and delta_y <= 1):
  print("No")
else:
  print("Yes")